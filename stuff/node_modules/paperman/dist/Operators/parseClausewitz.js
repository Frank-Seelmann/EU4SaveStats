"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseClausewitz = void 0;
var rxjs_1 = require("rxjs");
var ClausewitzObject_1 = require("../ClausewitzObject");
/**
 * @see parseClausewitz
 */
var ParseClausewitzSubscriber = /** @class */ (function (_super) {
    __extends(ParseClausewitzSubscriber, _super);
    function ParseClausewitzSubscriber(destination, gameInfo, logger) {
        var _this = _super.call(this, destination) || this;
        /**
         * Last identifier parsed before an equals object
         */
        _this.lastKey = 0;
        /**
         * Last identifier parsed
         */
        _this.lastIdentifier = 0;
        /**
         * List of parents above the current object
         */
        _this.parents = [];
        /**
         * Line buffer
         */
        _this.buffer = [];
        /**
         * Currently buffered line
         */
        //private line: string = '';
        /**
         * Is it time for a line break?
         */
        _this.newLine = false;
        _this.gameInfo = gameInfo;
        _this.logger = logger;
        _this.gameInfo.InitiateParser(_this);
        return _this;
    }
    Object.defineProperty(ParseClausewitzSubscriber.prototype, "parent", {
        /**
         * Shorthand function for getting the closest parent in the list
         * @see parents
         */
        get: function () {
            var parent = this.parents.slice(-1).pop();
            return parent !== undefined ? parent : 0;
        },
        set: function (parent) {
            this.parents.push(parent);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Buffer some text on the current line
     */
    ParseClausewitzSubscriber.prototype.put = function (value) {
        if (this.dropKeyValuePair !== undefined) {
            return;
        }
        this.buffer.push(value);
    };
    /**
     * Set the newLine flag (if the line isn't empty already)
     */
    ParseClausewitzSubscriber.prototype.lineFeed = function () {
        if (this.dropKeyValuePair !== undefined) {
            return;
        }
        this.newLine = this.buffer.length !== 0;
    };
    /**
     * Completes the current line and begins a new one.
     * @param indent Should the next line have indentation?
     */
    ParseClausewitzSubscriber.prototype.push = function (indent) {
        if (indent === void 0) { indent = true; }
        if (this.dropKeyValuePair !== undefined) {
            return;
        }
        if (!this.newLine) {
            return;
        }
        this.newLine = false;
        if (this.destination.next !== undefined) {
            this.destination.next(this.buffer.join(''));
        }
        this.buffer = [];
        if (indent) {
            this.buffer.push('\t'.repeat(this.parents.length));
        }
    };
    /**
     * @inheritdoc
     */
    ParseClausewitzSubscriber.prototype._complete = function () {
        if (this.buffer.length !== 0 && this.destination.next !== undefined) {
            this.destination.next(this.buffer.join(''));
        }
        if (this.destination.complete !== undefined) {
            this.destination.complete();
        }
    };
    /**
     * @inheritdoc
     */
    ParseClausewitzSubscriber.prototype._next = function (value) {
        var _this = this;
        // test for game-specific formatting rules for current context and value
        if (this.gameInfo.FormatRules.some(function (rule) { return rule(_this, value); })) {
            // do nothing
        }
        else if (ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'Equals')) {
            this.lastKey = this.lastIdentifier;
            if (this.dropKeyValuePair === undefined) {
                this.newLine = false;
            }
            this.put('=');
        }
        else if (ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'OpenGroup')) {
            this.parent = this.lastKey;
            this.push();
            this.put('{');
            this.lineFeed();
        }
        else if (ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'CloseGroup')) {
            var p = this.parents.pop();
            this.lineFeed();
            this.push();
            this.put('}');
            this.lineFeed();
            if (p === this.dropKeyValuePair) {
                this.dropKeyValuePair = undefined;
            }
        }
        else if (ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'IntegerA') || ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'IntegerB')) {
            this.push();
            this.put(value.value.toString());
            this.lineFeed();
        }
        else if (ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'FloatA')) {
            this.push();
            this.put(value.value.toFixed(3));
            this.lineFeed();
        }
        else if (ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'FloatB') || ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'FloatC')) {
            this.push();
            this.put(value.value.toFixed(5));
            this.lineFeed();
        }
        else if (ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'Boolean')) {
            this.push();
            this.put(value.value ? 'yes' : 'no');
            this.lineFeed();
        }
        else if (ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'StringA') || ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'StringB')) {
            this.push();
            this.put("\"" + value.value + "\"");
            this.lineFeed();
        }
        else if (ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'BooleanYesA') || ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'BooleanYesB')) {
            this.put('yes');
            this.lineFeed();
        }
        else if (ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'BooleanNo')) {
            this.put('no');
            this.lineFeed();
        }
        else if (ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'Other')) {
            var val = this.gameInfo.Dictionary[value.value];
            this.push();
            if (val !== undefined) {
                this.put(val);
            }
            else {
                this.put("unknown" + value.value); // rather than errorring on every
                // unknown key (gathering all keys is ~~an impossible task~~ a piece of cake), just emit
                // 'unknown\d' saves will be "fine"
                if (this.logger !== undefined) {
                    var dropped = this.dropKeyValuePair === undefined ? '' : ' (Dropped)';
                    this.logger.next("Unknown key " + value.value + " (0x" + value.value.toString(16) + ")" + dropped);
                }
            }
            if (this.lastIdentifier === 'Equals') {
                this.lineFeed();
            }
        }
        if (this.lastKey === this.dropKeyValuePair
            && !ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'OpenGroup')
            && this.lastIdentifier === 'Equals') {
            this.dropKeyValuePair = undefined;
        }
        this.lastIdentifier = ClausewitzObject_1.isClausewitzObjectOfIdentifier(value, 'Other') ? value.value : value.identifier;
    };
    return ParseClausewitzSubscriber;
}(rxjs_1.Subscriber));
/**
 * @see parseClausewitz
 */
var ParseClausewitzOperator = /** @class */ (function () {
    function ParseClausewitzOperator(gameInfo, logger) {
        this.gameInfo = gameInfo;
        this.logger = logger;
    }
    /**
     * @inheritdoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ParseClausewitzOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ParseClausewitzSubscriber(subscriber, this.gameInfo, this.logger));
    };
    return ParseClausewitzOperator;
}());
/**
 * ReactiveX Operator for turning ClausewitzObjects into plaintext save data the game can load
 * @param gameInfo specifies what game this save is for
 * @param logger an observer for receiving log messages
 */
function parseClausewitz(gameInfo, logger) {
    return function (source) {
        return source.lift(new ParseClausewitzOperator(gameInfo, logger));
    };
}
exports.parseClausewitz = parseClausewitz;
exports.default = parseClausewitz;
