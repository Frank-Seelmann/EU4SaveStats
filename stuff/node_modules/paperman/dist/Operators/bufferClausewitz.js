"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.bufferClausewitz = void 0;
var rxjs_1 = require("rxjs");
var ClausewitzObject_1 = require("../ClausewitzObject");
var identifierByShort = {
    1: 'Equals',
    3: 'OpenGroup',
    4: 'CloseGroup',
    12: 'IntegerA',
    13: 'FloatA',
    14: 'Boolean',
    15: 'StringA',
    20: 'IntegerB',
    23: 'StringB',
    359: 'FloatB',
    400: 'FloatC',
    10137: 'BooleanYesA',
    10315: 'BooleanYesB',
    10316: 'BooleanNo'
};
/**
 * @see bufferClausewitz
 */
var BufferClausewitzSubscriber = /** @class */ (function (_super) {
    __extends(BufferClausewitzSubscriber, _super);
    function BufferClausewitzSubscriber(destination, gameInfo) {
        var _this = _super.call(this, destination) || this;
        /**
         * Have we seen the opening save file identifier yet?
         */
        _this.seenMagicNumber = false;
        /**
         * Have we seen an identifier that precedes a value? We need to know which one. If not, null.
         */
        _this.expectingValue = null;
        _this.gameInfo = gameInfo;
        return _this;
    }
    /**
     * @inheritdoc
     */
    BufferClausewitzSubscriber.prototype._complete = function () {
        if (!this.seenMagicNumber) {
            this.desterror(new Error('not a valid savegame'));
        }
        if (this.buffer.length !== 0 || this.expectingValue !== null) {
            this.desterror(new Error('unexpected EOF'));
        }
        this.destcomplete();
    };
    /**
     * @inheritdoc
     */
    BufferClausewitzSubscriber.prototype._next = function (value) {
        if (this.buffer === undefined) {
            this.buffer = value;
        }
        else {
            this.buffer = Buffer.concat([this.buffer, value]);
        }
        var bufferindex = 0;
        while (this.destination.closed === false && bufferindex < this.buffer.length) {
            var increment = this.innerNext(bufferindex);
            if (increment === 0) {
                break;
            }
            else {
                bufferindex += increment;
            }
        }
        this.buffer = this.buffer.slice(bufferindex);
    };
    /**
     * Wrapper for this.destination.error that nullchecks before call.
     * @param err Error object
     * @see Subscriber<T>.destination.error
     */
    BufferClausewitzSubscriber.prototype.desterror = function (err) {
        if (this.destination.error !== undefined) {
            this.destination.error(err);
        }
    };
    /**
     * Wrapper for this.destination.complete that nullchecks before call.
     * @see Subscriber<T>.destination.complete
     */
    BufferClausewitzSubscriber.prototype.destcomplete = function () {
        if (this.destination.complete !== undefined) {
            this.destination.complete();
        }
    };
    /**
     * Wrapper for this.destination.next that nullchecks before call.
     * @param value Value to push
     * @see Subscriber<T>.destination.next
     */
    BufferClausewitzSubscriber.prototype.destnext = function (value) {
        if (this.destination.next !== undefined) {
            this.destination.next(value);
        }
    };
    /**
     * Scans for a single token in the buffer.
     * @param bufferindex Current index of the buffer
     * @returns 0 to stop, any other number to increment buffer
     */
    BufferClausewitzSubscriber.prototype.innerNext = function (bufferindex) {
        // wait for magic number
        if (!this.seenMagicNumber) {
            var _a = this.innerMagicNumber(bufferindex), magicNumberFound = _a[0], skip = _a[1];
            if (magicNumberFound) {
                if (skip > 0) {
                    return skip;
                }
            }
            else {
                return skip;
            }
        }
        // get the type identifier
        if (this.expectingValue === null) {
            return this.innerTypeIdentifier(bufferindex);
        }
        // get the value
        return this.innerValue(bufferindex);
    };
    /**
     * Checks if the buffer has the magic number
     * @param bufferindex Current index of the buffer
     */
    BufferClausewitzSubscriber.prototype.checkMagicNumber = function (bufferindex) {
        if (this.gameInfo.MagicNumber === null) {
            return [true, 0];
        }
        if (this.buffer.length - bufferindex < this.gameInfo.MagicNumber.length) {
            return [false, 0];
        }
        return [
            this.gameInfo.MagicNumber.compare(this.buffer, bufferindex, bufferindex + this.gameInfo.MagicNumber.length) === 0,
            this.gameInfo.MagicNumber.length
        ];
    };
    /**
     * Scans for the opening magic number in the buffer.
     * @param bufferindex Current index of the buffer
     */
    BufferClausewitzSubscriber.prototype.innerMagicNumber = function (bufferindex) {
        var _a = this.checkMagicNumber(bufferindex), magicNumberFound = _a[0], skip = _a[1];
        if (!magicNumberFound) {
            this.desterror(new Error('not a valid savegame'));
            return [magicNumberFound, skip];
        }
        else {
            this.seenMagicNumber = true;
            return [magicNumberFound, skip];
        }
    };
    /**
     * Scans for a type identifier in the buffer.
     * @param bufferindex Current index of the buffer
     */
    BufferClausewitzSubscriber.prototype.innerTypeIdentifier = function (bufferindex) {
        if (this.buffer.length - bufferindex < 2) {
            return 0;
        }
        var n = this.buffer.readInt16LE(bufferindex);
        var identifier = identifierByShort[n];
        switch (identifier) {
            case 'Equals':
            case 'OpenGroup':
            case 'CloseGroup':
            case 'BooleanYesA':
            case 'BooleanYesB':
            case 'BooleanNo':
                // the identifier is the value
                this.destnext(ClausewitzObject_1.createClausewitzObject(identifier));
                break;
            case 'IntegerA':
            case 'IntegerB':
            case 'FloatA':
            case 'Boolean':
            case 'StringA':
            case 'StringB':
            case 'FloatB':
            case 'FloatC':
                // value follows
                this.expectingValue = identifier;
                break;
            default:
                if (n > 19000) { // that's a very high identifier. are we sure it's not a new magic number?
                    var _a = this.checkMagicNumber(bufferindex), foundMagicNumber = _a[0], skip = _a[1];
                    if (foundMagicNumber) {
                        return skip;
                    }
                }
                // it's a token
                this.destnext(ClausewitzObject_1.createClausewitzObject(n));
        }
        return 2;
    };
    /**
     * Scans for the value following the identifier in the buffer.
     * @param bufferindex Current index of the buffer
     */
    BufferClausewitzSubscriber.prototype.innerValue = function (bufferindex) {
        if (this.expectingValue === null) {
            return -1;
        }
        switch (this.expectingValue) {
            case 'IntegerA':
            case 'IntegerB': {
                if (this.buffer.length - bufferindex < 4) {
                    return 0;
                }
                var int = this.buffer.readInt32LE(bufferindex);
                this.destnext(ClausewitzObject_1.createClausewitzObject(this.expectingValue, int));
                this.expectingValue = null;
                return 4;
            }
            case 'FloatA': {
                if (this.buffer.length - bufferindex < 4) {
                    return 0;
                }
                var float = this.buffer.readInt32LE(bufferindex);
                float = float / 1000;
                this.destnext(ClausewitzObject_1.createClausewitzObject(this.expectingValue, float));
                this.expectingValue = null;
                return 4;
            }
            case 'Boolean':
                this.destnext(ClausewitzObject_1.createClausewitzObject(this.expectingValue, this.buffer[bufferindex] !== 0));
                this.expectingValue = null;
                return 1;
            case 'StringA':
            case 'StringB': {
                if (this.buffer.length - bufferindex < 2) {
                    return 0;
                }
                var length_1 = this.buffer.readInt16LE(bufferindex);
                if (this.buffer.length - bufferindex < length_1 + 2) {
                    return 0;
                }
                var str = this.buffer.toString('binary', bufferindex + 2, bufferindex + 2 + length_1);
                this.destnext(ClausewitzObject_1.createClausewitzObject(this.expectingValue, str));
                this.expectingValue = null;
                return length_1 + 2;
            }
            case 'FloatB':
            case 'FloatC': {
                if (this.buffer.length - bufferindex < 8) {
                    return 0;
                }
                var floatb = this.buffer.readInt32LE(bufferindex);
                floatb = floatb / 65536 * 2;
                this.destnext(ClausewitzObject_1.createClausewitzObject(this.expectingValue, floatb));
                this.expectingValue = null;
                return 8;
            }
            // istanbul ignore next
            default:
                throw new Error('should never get here');
        }
    };
    return BufferClausewitzSubscriber;
}(rxjs_1.Subscriber));
/**
 * @see bufferClausewitz
 */
var BufferClausewitzOperator = /** @class */ (function () {
    function BufferClausewitzOperator(gameInfo) {
        this.gameInfo = gameInfo;
    }
    /**
     * @inheritdoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    BufferClausewitzOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferClausewitzSubscriber(subscriber, this.gameInfo));
    };
    return BufferClausewitzOperator;
}());
/**
 * ReactiveX Operator for turning binary data into ClausewitzObjects
 * @param gameInfo specifies what game this save is from
 */
function bufferClausewitz(gameInfo) {
    return function (source) {
        return source.lift(new BufferClausewitzOperator(gameInfo));
    };
}
exports.bufferClausewitz = bufferClausewitz;
exports.default = bufferClausewitz;
